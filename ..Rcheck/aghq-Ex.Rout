
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "aghq"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('aghq')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aghq")
> ### * aghq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aghq
> ### Title: Adaptive Gauss-Hermite Quadrature
> ### Aliases: aghq
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> 
> 
> 
> 
> cleanEx()
> nameEx("compute_moment")
> ### * compute_moment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute_moment
> ### Title: Compute moments
> ### Aliases: compute_moment compute_moment.default compute_moment.aghq
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> opt_sparsetrust_2d <- optimize_theta(funlist2d,c(1.5,1.5))
> norm_sparse_2d_7 <- normalize_logpost(opt_sparsetrust_2d,7,1)
> 
> # ff = function(x) 1 should return 1,
> # the normalizing constant of the (already normalized) posterior:
> compute_moment(norm_sparse_2d_7)
[1] 1
> # Compute the mean of theta1 and theta2
> compute_moment(norm_sparse_2d_7,ff = function(x) x)
[1] 1.321849 1.485452
> # Compute the mean of lambda1 = exp(theta1) and lambda2 = exp(theta2)
> lambdameans <- compute_moment(norm_sparse_2d_7,ff = function(x) exp(x))
> lambdameans
[1] 3.833353 4.500014
> # Compare them to the truth:
> (sum(y1) + 1)/(length(y1) + 1)
[1] 3.833333
> (sum(y2) + 1)/(length(y2) + 1)
[1] 4.5
> # Compute the standard deviation of lambda1
> lambda1sd <- sqrt(compute_moment(norm_sparse_2d_7,ff = function(x) (exp(x) - lambdameans[1])^2))[1]
> # ...and so on.
> 
> 
> 
> cleanEx()
> nameEx("compute_pdf_and_cdf")
> ### * compute_pdf_and_cdf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute_pdf_and_cdf
> ### Title: Density and Cumulative Distribution Function
> ### Aliases: compute_pdf_and_cdf compute_pdf_and_cdf.default
> ###   compute_pdf_and_cdf.list compute_pdf_and_cdf.aghq
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> opt_sparsetrust_2d <- optimize_theta(funlist2d,c(1.5,1.5))
> margpost <- marginal_posterior(opt_sparsetrust_2d,3,1) # margpost for theta1
> thepdfandcdf <- compute_pdf_and_cdf(margpost)
> with(thepdfandcdf,{
+   plot(pdf~theta,type='l')
+   plot(cdf~theta,type='l')
+ })
> 
> 
> 
> 
> cleanEx()
> nameEx("compute_quantiles")
> ### * compute_quantiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute_quantiles
> ### Title: Quantiles
> ### Aliases: compute_quantiles compute_quantiles.default
> ###   compute_quantiles.list compute_quantiles.aghq
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> opt_sparsetrust_2d <- optimize_theta(funlist2d,c(1.5,1.5))
> margpost <- marginal_posterior(opt_sparsetrust_2d,3,1) # margpost for theta1
> etaquant <- compute_quantiles(margpost)
> etaquant
     2.5%     97.5% 
0.9149731 1.7291141 
> # lambda = exp(eta)
> exp(etaquant)
    2.5%    97.5% 
2.496708 5.635659 
> # Compare to truth
> qgamma(.025,1+sum(y1),1+n1)
[1] 2.430005
> qgamma(.975,1+sum(y1),1+n1)
[1] 5.551377
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("default_control")
> ### * default_control
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_control
> ### Title: Default control arguments for 'aghq::aghq()'.
> ### Aliases: default_control
> 
> ### ** Examples
> 
> 
> default_control()
$method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control(method = "trust")
$method
[1] "trust"

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control(negate = TRUE)
$method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] TRUE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> 
> 
> 
> 
> cleanEx()
> nameEx("default_control_marglaplace")
> ### * default_control_marglaplace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_control_marglaplace
> ### Title: Default control arguments for 'aghq::marginal_laplace()'.
> ### Aliases: default_control_marglaplace
> 
> ### ** Examples
> 
> 
> default_control_marglaplace()
$method
[1] "BFGS"         "sparse_trust" "trust"       

$inner_method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control_marglaplace(method = "trust")
$method
[1] "trust"

$inner_method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control_marglaplace(method = "trust",inner_method = "trust")
$method
[1] "trust"

$inner_method
[1] "trust"

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control_marglaplace(negate = TRUE)
$method
[1] "BFGS"         "sparse_trust" "trust"       

$inner_method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] TRUE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> 
> 
> 
> 
> cleanEx()
> nameEx("default_control_tmb")
> ### * default_control_tmb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_control_tmb
> ### Title: Default control arguments for 'aghq::marginal_laplace_tmb()'.
> ### Aliases: default_control_tmb
> 
> ### ** Examples
> 
> 
> default_control_marglaplace()
$method
[1] "BFGS"         "sparse_trust" "trust"       

$inner_method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control_marglaplace(method = "trust")
$method
[1] "trust"

$inner_method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control_marglaplace(method = "trust",inner_method = "trust")
$method
[1] "trust"

$inner_method
[1] "trust"

$negate
[1] FALSE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> default_control_marglaplace(negate = TRUE)
$method
[1] "BFGS"         "sparse_trust" "trust"       

$inner_method
[1] "BFGS"         "sparse_trust" "trust"       

$negate
[1] TRUE

$ndConstruction
[1] "product"

$interpolation
[1] "auto"

$numhessian
[1] FALSE

$onlynormconst
[1] FALSE

> 
> 
> 
> 
> cleanEx()
> nameEx("laplace_approximation")
> ### * laplace_approximation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: laplace_approximation
> ### Title: Laplace Approximation
> ### Aliases: laplace_approximation
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> 
> 
> 
> 
> cleanEx()
> nameEx("marginal_laplace")
> ### * marginal_laplace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marginal_laplace
> ### Title: Marginal Laplace approximation
> ### Aliases: marginal_laplace
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> objfunc2dmarg <- function(W,theta) objfunc2d(c(W,theta))
> objfunc2dmarggr <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::grad(fn,W)
+ }
> objfunc2dmarghe <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::hessian(fn,W)
+ }
> 
> funlist2dmarg <- list(
+   fn = objfunc2dmarg,
+   gr = objfunc2dmarggr,
+   he = objfunc2dmarghe
+ )
> 
> 
> 
> cleanEx()
> nameEx("marginal_posterior")
> ### * marginal_posterior
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: marginal_posterior
> ### Title: Marginal Posteriors
> ### Aliases: marginal_posterior
> 
> ### ** Examples
> 
> ## A 2d example ##
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> opt_sparsetrust_2d <- optimize_theta(funlist2d,c(1.5,1.5))
> 
> # Now actually do the marginal posteriors
> marginal_posterior(opt_sparsetrust_2d,3,1)
     theta1 logmargpost         w
1 0.9825772  -0.6858243 0.3904060
2 1.3437347   0.6487910 0.3484454
3 1.7048923  -1.0493445 0.3904060
> marginal_posterior(opt_sparsetrust_2d,3,2)
    theta2 logmargpost         w
1 1.170744  -0.6173783 0.3603284
2 1.504077   0.7289671 0.3216006
3 1.837411  -0.9525684 0.3603284
> marginal_posterior(opt_sparsetrust_2d,7,2)
     theta2  logmargpost         w
1 0.7823049 -4.880999099 0.2997443
2 1.0485943 -1.693970252 0.2441827
3 1.2819120  0.106290324 0.2255401
4 1.5040774  0.725894646 0.2205261
5 1.7262428  0.007356766 0.2255401
6 1.9595605 -2.553306487 0.2441827
7 2.2258499 -8.354350629 0.2997443
> 
> 
> 
> 
> cleanEx()
> nameEx("normalize_logpost")
> ### * normalize_logpost
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: normalize_logpost
> ### Title: Normalize the joint posterior using AGHQ
> ### Aliases: normalize_logpost
> 
> ### ** Examples
> 
> # Same setup as optimize_theta
> logfteta <- function(eta,y) {
+   sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y+1)) + eta
+ }
> set.seed(84343124)
> y <- rpois(10,5) # Mode should be sum(y) / (10 + 1)
> truemode <- log((sum(y) + 1)/(length(y) + 1))
> objfunc <- function(x) logfteta(x,y)
> funlist <- list(
+   fn = objfunc,
+   gr = function(x) numDeriv::grad(objfunc,x),
+   he = function(x) numDeriv::hessian(objfunc,x)
+ )
> opt_sparsetrust <- optimize_theta(funlist,1.5)
> opt_trust <- optimize_theta(funlist,1.5,control = default_control(method = "trust"))
> opt_bfgs <- optimize_theta(funlist,1.5,control = default_control(method = "BFGS"))
> 
> # Quadrature with 3, 5, and 7 points using sparse trust region optimization:
> norm_sparse_3 <- normalize_logpost(opt_sparsetrust,3,1)
> norm_sparse_5 <- normalize_logpost(opt_sparsetrust,5,1)
> norm_sparse_7 <- normalize_logpost(opt_sparsetrust,7,1)
> 
> # Quadrature with 3, 5, and 7 points using dense trust region optimization:
> norm_trust_3 <- normalize_logpost(opt_trust,3,1)
> norm_trust_5 <- normalize_logpost(opt_trust,5,1)
> norm_trust_7 <- normalize_logpost(opt_trust,7,1)
> 
> # Quadrature with 3, 5, and 7 points using BFGS optimization:
> norm_bfgs_3 <- normalize_logpost(opt_bfgs,3,1)
> norm_bfgs_5 <- normalize_logpost(opt_bfgs,5,1)
> norm_bfgs_7 <- normalize_logpost(opt_bfgs,7,1)
> 
> 
> 
> 
> cleanEx()
> nameEx("optimize_theta")
> ### * optimize_theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optimize_theta
> ### Title: Obtain function information necessary for performing quadrature
> ### Aliases: optimize_theta
> 
> ### ** Examples
> 
> # Poisson/Exponential example
> logfteta <- function(eta,y) {
+   sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y+1)) + eta
+ }
> 
> y <- rpois(10,5) # Mode should be (sum(y) + 1) / (length(y) + 1)
> 
> objfunc <- function(x) logfteta(x,y)
> funlist <- list(
+   fn = objfunc,
+   gr = function(x) numDeriv::grad(objfunc,x),
+   he = function(x) numDeriv::hessian(objfunc,x)
+ )
> 
> optimize_theta(funlist,1.5)
$ff
$ff$fn
function (x) 
logfteta(x, y)
<bytecode: 0x7ffb479a0050>

$ff$gr
function (x) 
numDeriv::grad(objfunc, x)
<bytecode: 0x7ffb4719ee38>

$ff$he
function (x) 
numDeriv::hessian(objfunc, x)


$mode
[1] 1.627456

$hessian
     [,1]
[1,]   56

$convergence
[1] 0

> optimize_theta(funlist,1.5,control = default_control(method = "trust"))
$ff
$ff$fn
function (x) 
logfteta(x, y)
<bytecode: 0x7ffb479a0050>

$ff$gr
function (x) 
numDeriv::grad(objfunc, x)
<bytecode: 0x7ffb4719ee38>

$ff$he
function (x) 
numDeriv::hessian(objfunc, x)
<bytecode: 0x7ffb4515ba18>


$mode
[1] 1.627456

$hessian
     [,1]
[1,]   56

$convergence
[1] TRUE

> optimize_theta(funlist,1.5,control = default_control(method = "BFGS"))
$ff
$ff$fn
function (x) 
logfteta(x, y)
<bytecode: 0x7ffb479a0050>

$ff$gr
function (x) 
numDeriv::grad(objfunc, x)
<bytecode: 0x7ffb4719ee38>

$ff$he
function (x) 
numDeriv::hessian(objfunc, x)
<bytecode: 0x7ffb4515ba18>


$mode
[1] 1.627456

$hessian
     [,1]
[1,]   56

$convergence
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("plot.aghq")
> ### * plot.aghq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.aghq
> ### Title: Plot method for AGHQ objects
> ### Aliases: plot.aghq
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> plot(thequadrature)
> 
> 
> 
> 
> cleanEx()
> nameEx("print.aghq")
> ### * print.aghq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.aghq
> ### Title: Print method for AGHQ objects
> ### Aliases: print.aghq
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> thequadrature
aghq object. 

Use summary(...) to see more detailed information,

plot(...) to see plots of marginal distributions, and 

?compute_moment to see a list of useful summary methods.
 > 
> 
> 
> 
> cleanEx()
> nameEx("print.aghqsummary")
> ### * print.aghqsummary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.aghqsummary
> ### Title: Print method for AGHQ summary objects
> ### Aliases: print.aghqsummary
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> # Summarize and automatically call its print() method when called interactively:
> summary(thequadrature)
AGHQ on a 2 dimensional posterior with  3 3 quadrature points

The posterior mode is: 1.343735 1.504077 

The log of the normalizing constant/marginal likelihood is: -26.35836 

The covariance matrix used for the quadrature is...
             [,1]         [,2]
[1,] 4.347827e-02 2.634560e-19
[2,] 2.634560e-19 3.703704e-02

Here are some moments and quantiles for theta:

           mean   median     mode        sd     2.5%    97.5%
theta1 1.322090 1.321320 1.343735 0.2073917 0.914973 1.729114
theta2 1.485628 1.484725 1.504077 0.1915662 1.109683 1.861101

> 
> 
> 
> 
> cleanEx()
> nameEx("print.laplace")
> ### * print.laplace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.laplace
> ### Title: Print method for AGHQ objects
> ### Aliases: print.laplace
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> thequadrature
aghq object. 

Use summary(...) to see more detailed information,

plot(...) to see plots of marginal distributions, and 

?compute_moment to see a list of useful summary methods.
 > 
> 
> 
> 
> cleanEx()
> nameEx("print.laplacesummary")
> ### * print.laplacesummary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.laplacesummary
> ### Title: Print method for laplacesummary objects
> ### Aliases: print.laplacesummary
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thelaplace <- laplace_approximation(funlist2d,c(0,0))
> # Summarize and automatically call its print() method when called interactively:
> summary(thelaplace)
Laplace approximation for a 2 dimensional posterior

The posterior mode is: 1.344 1.504 

The log of the normalizing constant/marginal likelihood is: -26.35839 


> 
> 
> 
> 
> cleanEx()
> nameEx("print.marginallaplacesummary")
> ### * print.marginallaplacesummary
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.marginallaplacesummary
> ### Title: Summary statistics for models using marginal Laplace
> ###   approximations
> ### Aliases: print.marginallaplacesummary
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> objfunc2dmarg <- function(W,theta) objfunc2d(c(W,theta))
> objfunc2dmarggr <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::grad(fn,W)
+ }
> objfunc2dmarghe <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::hessian(fn,W)
+ }
> 
> funlist2dmarg <- list(
+   fn = objfunc2dmarg,
+   gr = objfunc2dmarggr,
+   he = objfunc2dmarghe
+ )
> 
> themarginallaplace <- aghq::marginal_laplace(funlist2dmarg,3,list(W = 0,theta = 0))
> summary(themarginallaplace)

==========================================================

Fixed effects:
AGHQ on a 1 dimensional posterior with  3 quadrature points

The posterior mode is: 1.504048 

The log of the normalizing constant/marginal likelihood is: -26.35838 

The covariance matrix used for the quadrature is...
           [,1]
[1,] 0.03703813

Here are some moments and quantiles for theta:

           mean   median     mode        sd     2.5%    97.5%
theta1 1.485627 1.484695 1.504048 0.1915689 1.109648 1.861077

==========================================================

Random effects, based on 1000 approximate posterior samples:
      mean   median     mode        sd      2.5%    97.5% variable
1 1.349209 1.351416 1.343735 0.2070178 0.9562857 1.756494       W1
> 
> 
> 
> cleanEx()
> nameEx("sample_marginal")
> ### * sample_marginal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sample_marginal
> ### Title: Exact independent samples from an approximate posterior
> ###   distribution
> ### Aliases: sample_marginal sample_marginal.aghq
> ###   sample_marginal.marginallaplace
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> objfunc2dmarg <- function(W,theta) objfunc2d(c(W,theta))
> objfunc2dmarggr <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::grad(fn,W)
+ }
> objfunc2dmarghe <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::hessian(fn,W)
+ }
> 
> funlist2dmarg <- list(
+   fn = objfunc2dmarg,
+   gr = objfunc2dmarggr,
+   he = objfunc2dmarghe
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("summary.aghq")
> ### * summary.aghq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.aghq
> ### Title: Summary statistics computed using AGHQ
> ### Aliases: summary.aghq
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thequadrature <- aghq(funlist2d,3,c(0,0))
> # Summarize and automatically call its print() method when called interactively:
> summary(thequadrature)
AGHQ on a 2 dimensional posterior with  3 3 quadrature points

The posterior mode is: 1.343735 1.504077 

The log of the normalizing constant/marginal likelihood is: -26.35836 

The covariance matrix used for the quadrature is...
             [,1]         [,2]
[1,] 4.347827e-02 2.634560e-19
[2,] 2.634560e-19 3.703704e-02

Here are some moments and quantiles for theta:

           mean   median     mode        sd     2.5%    97.5%
theta1 1.322090 1.321320 1.343735 0.2073917 0.914973 1.729114
theta2 1.485628 1.484725 1.504077 0.1915662 1.109683 1.861101

> # or, compute the summary and save for further processing:
> ss <- summary(thequadrature)
> str(ss)
List of 8
 $ mode        : num [1:2] 1.34 1.5
 $ hessian     : num [1:2, 1:2] 2.30e+01 -1.64e-16 -1.64e-16 2.70e+01
 $ lognormconst: num -26.4
 $ covariance  : num [1:2, 1:2] 4.35e-02 2.63e-19 2.63e-19 3.70e-02
 $ cholesky    : num [1:2, 1:2] 2.09e-01 0.00 1.26e-18 1.92e-01
 $ quadpoints  : num [1:2] 3 3
 $ dim         : int 2
 $ summarytable:'data.frame':	2 obs. of  6 variables:
  ..$ mean  : num [1:2] 1.32 1.49
  ..$ median: num [1:2] 1.32 1.48
  ..$ mode  : num [1:2] 1.34 1.5
  ..$ sd    : num [1:2] 0.207 0.192
  ..$ 2.5%  : num [1:2] 0.915 1.11
  ..$ 97.5% : num [1:2] 1.73 1.86
 - attr(*, "class")= chr "aghqsummary"
> 
> 
> 
> 
> cleanEx()
> nameEx("summary.laplace")
> ### * summary.laplace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.laplace
> ### Title: Summary method for Laplace Approximation objects
> ### Aliases: summary.laplace
> 
> ### ** Examples
> 
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> funlist2d <- list(
+   fn = objfunc2d,
+   gr = function(x) numDeriv::grad(objfunc2d,x),
+   he = function(x) numDeriv::hessian(objfunc2d,x)
+ )
> 
> thelaplace <- laplace_approximation(funlist2d,c(0,0))
> # Summarize and automatically call its print() method when called interactively:
> summary(thelaplace)
Laplace approximation for a 2 dimensional posterior

The posterior mode is: 1.344 1.504 

The log of the normalizing constant/marginal likelihood is: -26.35839 


> 
> 
> 
> 
> cleanEx()
> nameEx("summary.marginallaplace")
> ### * summary.marginallaplace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.marginallaplace
> ### Title: Summary statistics for models using marginal Laplace
> ###   approximations
> ### Aliases: summary.marginallaplace
> 
> ### ** Examples
> 
> logfteta2d <- function(eta,y) {
+   # eta is now (eta1,eta2)
+   # y is now (y1,y2)
+   n <- length(y)
+   n1 <- ceiling(n/2)
+   n2 <- floor(n/2)
+   y1 <- y[1:n1]
+   y2 <- y[(n1+1):(n1+n2)]
+   eta1 <- eta[1]
+   eta2 <- eta[2]
+   sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
+     sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
+ }
> set.seed(84343124)
> n1 <- 5
> n2 <- 5
> n <- n1+n2
> y1 <- rpois(n1,5)
> y2 <- rpois(n2,5)
> objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
> objfunc2dmarg <- function(W,theta) objfunc2d(c(W,theta))
> objfunc2dmarggr <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::grad(fn,W)
+ }
> objfunc2dmarghe <- function(W,theta) {
+   fn <- function(W) objfunc2dmarg(W,theta)
+   numDeriv::hessian(fn,W)
+ }
> 
> funlist2dmarg <- list(
+   fn = objfunc2dmarg,
+   gr = objfunc2dmarggr,
+   he = objfunc2dmarghe
+ )
> 
> themarginallaplace <- aghq::marginal_laplace(funlist2dmarg,3,list(W = 0,theta = 0))
> summary(themarginallaplace)

==========================================================

Fixed effects:
AGHQ on a 1 dimensional posterior with  3 quadrature points

The posterior mode is: 1.504048 

The log of the normalizing constant/marginal likelihood is: -26.35838 

The covariance matrix used for the quadrature is...
           [,1]
[1,] 0.03703813

Here are some moments and quantiles for theta:

           mean   median     mode        sd     2.5%    97.5%
theta1 1.485627 1.484695 1.504048 0.1915689 1.109648 1.861077

==========================================================

Random effects, based on 1000 approximate posterior samples:
      mean   median     mode        sd      2.5%    97.5% variable
1 1.349209 1.351416 1.343735 0.2070178 0.9562857 1.756494       W1
> 
> 
> 
> cleanEx()
> nameEx("validate_control")
> ### * validate_control
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validate_control
> ### Title: Validate a control list
> ### Aliases: validate_control
> 
> ### ** Examples
> 
> validate_control(default_control())
[1] TRUE
> validate_control(default_control_marglaplace(),type = "marglaplace")
[1] TRUE
> validate_control(default_control_tmb(),type = "tmb")
[1] TRUE
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.453 0.131 1.594 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
